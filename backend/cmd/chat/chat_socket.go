package chat

import (
	"backend/cmd/chat/rooms"
	"backend/internal/adminpanel/entities"
	"backend/internal/adminpanel/services/utils"
	"encoding/json"
	"fmt"
	"github.com/google/uuid"
	"log"
	"net/http"
	"sync"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/gorilla/websocket"
)

// –ü—ñ–¥–∫–ª—é—á–µ–Ω—ñ –∫–ª—ñ—î–Ω—Ç–∏ {chatID: [WebSocket-–∑'—î–¥–Ω–∞–Ω–Ω—è]}
var clients = make(map[uuid.UUID]map[*websocket.Conn]bool)
var mutex = sync.Mutex{}

// –û–Ω–æ–≤–ª—é–≤–∞—á WebSocket-–∑'—î–¥–Ω–∞–Ω–Ω—è
var upgrader = websocket.Upgrader{
	CheckOrigin: func(r *http.Request) bool {
		return true
	},
}

type MessagePayload struct {
	ID         uuid.UUID `json:"id"`
	RoomId     uuid.UUID `json:"room_id"`
	UserId     uuid.UUID `json:"user_id"`
	Message    string    `json:"message"`
	ContentUrl []string  `json:"content_url"` // –Ω–æ–≤–µ –ø–æ–ª–µ
	FullName   string    `json:"full_name"`   // –¥–ª—è broadcast
	Avatar     string    `json:"avatar"`      // –¥–ª—è broadcast
	CreatedAt  string    `json:"created_at"`  // ISO string –∑ —Ñ—Ä–æ–Ω—Ç–∞
}

func HandleWebSocket(ctx *gin.Context) {
	token := ctx.Query("token")
	_, err := utils.VerifyResetToken(token)
	if err != nil {
		ctx.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token"})
		return
	}

	db, ok := utils.GetDBFromContext(ctx)
	if !ok {
		return
	}

	roomID, err := uuid.Parse(ctx.Query("room_id"))
	if err != nil {
		ctx.JSON(http.StatusBadRequest, gin.H{"error": "Invalid room_id"})
		return
	}

	user, err := utils.ParseJWTToken(token)
	if err != nil {
		ctx.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token"})
		return
	}

	fmt.Printf("–ö–ª—ñ—î–Ω—Ç –∑ ID %s –ø—ñ–¥–∫–ª—é—á–∏–≤—Å—è –¥–æ –∫—ñ–º–Ω–∞—Ç–∏ %s\n", user.ID, roomID)

	conn, err := upgrader.Upgrade(ctx.Writer, ctx.Request, nil)
	if err != nil {
		fmt.Println("–ü–æ–º–∏–ª–∫–∞ WebSocket:", err)
		return
	}
	defer conn.Close()

	mutex.Lock()
	if clients[roomID] == nil {
		clients[roomID] = make(map[*websocket.Conn]bool)
	}
	clients[roomID][conn] = true
	mutex.Unlock()

	history, err := rooms.GetAllMessages(db, roomID)
	if err != nil {
		log.Println("‚ùå –ù–µ –≤–¥–∞–ª–æ—Å—è –æ—Ç—Ä–∏–º–∞—Ç–∏ —ñ—Å—Ç–æ—Ä—ñ—é —á–∞—Ç—É:", err)
	} else {
		historyData, _ := json.Marshal(history)
		conn.WriteMessage(websocket.TextMessage, historyData)
	}

	for {
		_, msg, err := conn.ReadMessage()
		if err != nil {
			log.Println("–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á –≤—ñ–¥–∫–ª—é—á–∏–≤—Å—è:", user.ID)
			mutex.Lock()
			delete(clients[roomID], conn)
			mutex.Unlock()
			break
		}

		// –†–æ–∑–ø–∞—Ä—Å–∏–º–æ —è–∫ raw JSON
		var raw map[string]interface{}
		if err := json.Unmarshal(msg, &raw); err != nil {
			log.Println("‚ùå JSON –ø–æ–º–∏–ª–∫–∞:", err)
			continue
		}

		if raw["type"] == "update_message" {
			messageIDStr, _ := raw["id"].(string)
			messageID, err := uuid.Parse(messageIDStr)
			if err != nil {
				log.Println("‚ùå –ù–µ–≤–∞–ª—ñ–¥–Ω–∏–π ID:", messageIDStr)
				continue
			}

			// ‚úÖ –û—Ç—Ä–∏–º—É—î–º–æ –æ–Ω–æ–≤–ª–µ–Ω–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –∑ –º–µ–¥—ñ–∞
			allMessages, err := rooms.GetAllMessages(db, roomID)
			if err != nil {
				log.Println("‚ùå GetAllMessages –ø–æ–º–∏–ª–∫–∞:", err)
				continue
			}

			for _, msg := range allMessages {
				if msg.ID == messageID.String() {
					// üîÑ –ü–æ–≤–Ω—ñ—Å—Ç—é –æ–Ω–æ–≤–ª–µ–Ω–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è (—ñ–∑ content_url —ñ–∑ —Ç–∞–±–ª–∏—Ü—ñ media)
					out, _ := json.Marshal(msg)
					broadcastMessage(roomID, out)
					break
				}
			}

			continue
		}

		// üì® –ó–≤–∏—á–∞–π–Ω–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
		var payload MessagePayload
		if err := json.Unmarshal(msg, &payload); err != nil {
			log.Println("‚ùå Payload decode error:", err)
			continue
		}

		message := entities.Messages{
			ID:        payload.ID,
			UserId:    user.ID,
			RoomId:    roomID,
			Message:   payload.Message,
			CreatedAt: time.Now(),
		}
		db.Create(&message)

		broadcastMessage(roomID, msg)
	}
}

// –§—É–Ω–∫—Ü—ñ—è –¥–ª—è —Ä–æ–∑—Å–∏–ª–∫–∏ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å
func broadcastMessage(chatID uuid.UUID, message []byte) {
	mutex.Lock()
	defer mutex.Unlock()
	for client := range clients[chatID] {
		err := client.WriteMessage(websocket.TextMessage, message)
		if err != nil {
			client.Close()
			delete(clients[chatID], client)
		}
	}
}
